# Koko Pic API アーキテクチャドキュメント

## 概要
このドキュメントは、Koko Pic API のアーキテクチャ、コンポーネント、関係性、および実装詳細について包括的に説明します。

## なぜこのアーキテクチャが存在するのか (Why)

Koko Pic API は、以下の重要な目標を達成するためにモジュール式のレイヤードアーキテクチャを採用しています：

1. **関心事の分離**: 異なるレイヤーが特定の責任（プレゼンテーション、ビジネスロジック、データアクセス）を処理
2. **テスト可能性**: 明確なインターフェースと依存性注入によりユニットテストが容易に
3. **保守性**: モジュール設計により更新や変更が容易に
4. **スケーラビリティ**: 明確に定義された境界により水平スケーリングが可能に
5. **セキュリティ**: 認証・認可層が独立している
6. **スレッド安全性**: 並列アクセスに対する適切な状態管理

## 何が存在するのか (What)

アプリケーションは、レイヤードアーキテクチャで整理されたいくつかの主要コンポーネントで構成されています：

### 1. アプリケーション層
- **app.rs**: メインルーターとアプリケーションセットアップ
- HTTP ルーティングとリクエスト/レスポンス処理を担当

### 2. ステート管理層
- **state.rs**: 共有アプリケーションステート管理
- 依存性注入とリソース共有を処理

### 3. ドメイン層（ユーザードメイン）
- **model.rs**: データ構造とデータベースエンティティ
- **repository.rs**: データアクセス操作
- **service.rs**: ビジネスロジック実装

## どのようにコンポーネントが連携するのか (How)

### コンポーネントの関係性

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   app.rs        │    │   state.rs       │    │   User Domain   │
│                 │    │                  │    │                 │
│  Router         │◄───┤  SharedAppState  │◄───┤  Service        │
│  Handlers       │    │  AppState Trait  │    │  Repository     │
│                 │    │                  │    │  Model          │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
   HTTP Requests        Shared Resources        Business Logic &
                                                  Data Access
```

### 詳細なコンポーネント相互作用

#### 1. アプリケーション層 (app.rs)
- **目的**: エントリーポイントとルーティング設定
- **動作方法**:
  - メインAxumルーターを作成
  - ルートハンドラーとネストされたユーザールートを設定
  - 共有アプリケーションステートをルーターにアタッチ
- **コード規約**:
  - ルーターの初期化には `create_app` 関数を使用
  - ルートハンドラーは薄く保ち、サービスに委譲する
  - ステートとドメインコンポーネントはフルパスでインポート
- **関係性**:
  - アプリケーションステートのために `state.rs` に依存
  - APIエンドポイントのためにユーザードメインの `user_routes()` を使用
  - アプリケーションへのHTTPインターフェースを提供

#### 2. ステート管理 (state.rs)
- **目的**: 中央集権的なステート管理と依存性注入
- **動作方法**:
  - 操作メソッドを持つ `AppState` トレイトを定義
  - サービスインスタンスを保持する `SharedAppState` 構造体を実装
  - スレッドセーフな共有のために `Arc` (アトミック参照カウント) を使用
  - データベース接続でサービスを初期化
- **コード規約**:
  - 非同期メソッドシグネチャを持つ `AppState` トレイトを定義
  - `SharedAppState` に `#[derive(Clone)]` を使用
  - サービスを初期化する非同期 `new` 関数を実装
  - スレッドセーフにするためにサービスを `Arc` でラップ
- **関係性**:
  - アプリ層とドメインサービスの橋渡し役
  - ハンドラーへの依存性（データベースプール、リポジトリ、サービス）を注入
  - アプリケーション操作の統一インターフェースを提供
  - サービス実装を保持する `SharedAppState` によって実装

#### 3. ユーザードメインコンポーネント

##### モデル (model.rs)
- **目的**: データ構造とデータベース操作を定義
- **動作方法**:
  - リクエストとレスポンスのためのデータ転送オブジェクト(DTO)を含む
  - データベースマッピングを持つエンティティを定義
  - データベース操作の静的メソッドを提供
- **コード規約**:
  - データ構造には `Debug`、`Clone`、`FromRow`、`Deserialize`、`Serialize` を導出
  - タイムスタンプには `chrono::DateTime<Utc>` を使用
  - データベース操作のためのエンティティに静的メソッドを実装
  - データベース接続には `PgPool` を使用
- **関係性**:
  - リポジトリ層とサービス層の両方で使用
  - レイヤー間のデータ契約を定義
  - エンティティ構造とリクエスト/レスポンスDTOを含む

##### リポジトリ (repository.rs)
- **目的**: データアクセス操作を抽象化
- **動作方法**:
  - データベース操作のための `async_trait` を持つリポジトリトレイトを定義
  - データベース操作を持つ具体的なリポジトリを実装
  - SQLx を使用したデータベース相互作用
- **コード規約**:
  - 非同期トレイト定義には `#[async_trait]` を使用
  - スレッドセーフにするために `Send + Sync` を実装
  - 必要に応じてジェネリック型パラメータを使用
  - 具象実装には `Sqlx` 接頭辞を使用（例：`SqlxUserRepository`）
- **関係性**:
  - データベースプールに依存する具象リポジトリによって実装
  - サービス層によるデータアクセスに使用
  - データベース操作のクリーンな抽象化を提供

##### サービス (service.rs)
- **目的**: ビジネスロジックを実装し、操作を調整
- **動作方法**:
  - ビジネス操作を持つサービストレイトを定義
  - ビジネスロジックを持つサービス実装を実装
  - 認証、検証、調整を処理
- **コード規約**:
  - 非同期トレイト定義には `#[async_trait]` を使用
  - ドメイン固有のエラーのためのカスタムエラー列挙型を定義
  - エラー変換のために `From` トレイトを実装
  - リポジトリ依存性のためのジェネリック型パラメータを使用
- **関係性**:
  - データアクセスのためにリポジトリ層に依存
  - データ転送のためにモデルを使用
  - ビジネス操作を実行するためにステート層から呼び出される
  - `state.rs` で定義されたトレイトメソッドを実装

## アーキテクチャフロー

### リクエスト処理フロー
1. HTTPリクエストが `app.rs` のルーターに到着
2. ルーターが `SharedAppState` で適切なハンドラーにディスパッチ
3. ハンドラーがステートのメソッドを呼び出し、サービスに委譲
4. サービスがリポジトリを使用してデータにアクセス
5. モデルがレイヤー間で渡されるデータ構造を定義
6. レスポンスが同じレイヤーを通ってクライアントに戻る

### 依存性注入フロー
1. `PgPool` (データベース接続) が起動時に作成される
2. リポジトリがプールでインスタンス化される
3. サービス実装がリポジトリで作成される
4. `SharedAppState` が `Arc` でラップされたサービスで作成される
5. ステートがルーターにアタッチされ、すべてのハンドラーで利用可能になる

### エラー処理フロー
1. データベースエラー (`sqlx::Error`) がリポジトリ層で発生
2. リポジトリエラーがサービス層に伝播
3. サービス層がドメイン固有のエラーに変換
4. ステート層がエラーをハンドラーに伝播
5. ハンドラーがエラーを適切なHTTPレスポンスに変換

## 主要な実装詳細

### コード規約
- プロジェクトの `rustfmt.toml` 設定で `rustfmt` を使用（2スペースインデント、最大幅120文字）
- Rustの命名規則に従う：関数/モジュールは `snake_case`、型は `CamelCase`、定数は `SCREAMING_SNAKE_CASE`
- ハンドラーとルートは小さく集中させ、APIが成長するにつれてモジュールを抽出する
- 適切なエラーハンドリングで非同期関数を一貫してフォーマット

### セキュリティ対策
- パスワードは保存前にユーティリティ関数でハッシュ化
- JWTトークンは有効期限（24時間）で生成
- JWTシークレットには環境変数を使用
- 情報漏洩を防ぐための適切なエラーハンドリング

### スレッド安全性
- スレッド間でのサービス共有に `Arc` (アトミック参照カウント) を使用
- ステートは並列アクセスのために `Clone`、`Send`、`Sync` トレイトを実装
- 接続プーリングは並列データベースアクセスを処理

### テストに関する考慮事項
- テストは実DB前提で記述し、`#[sqlx::test]` でテストごとに新規DB生成・migrations適用・自動破棄
- API/ハンドラは `Router` を直接叩くE2E寄りのテストを採用
- モデル層はDB操作の正否に絞った小さなテストを配置

## Rustコードスタイル

### フォーマット
- プロジェクトの `rustfmt.toml` 設定で `rustfmt` を使用
- 2スペースインデント
- 最大行幅120文字
- 自動フォーマットには `cargo fmt` を使用

### 命名規則
- 関数、変数、モジュールには `snake_case`
- 型、構造体、列挙型、トレイトには `CamelCase`
- 定数には `SCREAMING_SNAKE_CASE`
- 明確化のために非同期関数に `async_` でプレフィックスを付ける（必要に応じて）

### コード組織
- 関連機能をモジュールでグループ化
- テストはコードとともに `mod tests` ブロックを使用
- 関数は焦点を絞り、長さを制限（理想的には < 50 行）
- 複雑なロジックは個別の関数に抽出

## アーキテクチャパターン

### レイヤードアーキテクチャ
アプリケーションは、明確な関心事の分離を持つレイヤードアーキテクチャに従います：

1. **プレゼンテーション層** (`app.rs`)
   - HTTPルーティングとリクエスト/レスポンス処理を処理
   - サービスに委譲する薄い層
   - ビジネスロジックを含んではならない

2. **ステート管理層** (`state.rs`)
   - 共有アプリケーションステートを管理
   - 依存性注入を処理
   - サービスへのスレッドセーフなアクセスを提供

3. **ドメイン層** (`src/domains/*`)
   - ビジネスロジックとデータアクセスを含む
   - ドメインごとに整理（例：ユーザードメイン）
   - モデル、リポジトリ、サービスサブレイヤーにさらに分割

### ドメイン構造
各ドメインは以下の構造に従う必要があります：
```
src/domains/{domain_name}/
├── mod.rs          # モジュール宣言
├── model.rs        # データ構造とデータベースエンティティ
├── repository.rs   # データアクセス操作
├── service.rs      # ビジネスロジック
└── rest.rs         # このドメインのAPIエンドポイント
```

### リポジトリパターン
- データアクセス操作のための `async_trait` を持つリポジトリトレイトを定義
- これらのトレイトを実装する具象リポジトリを実装
- 異なるリポジトリ実装を許可するためのジェネリック型パラメータを使用
- データベースクエリはリポジトリ実装内に配置

### サービス層
- ビジネス操作のための `async_trait` を持つサービストレイトを定義
- リポジトリに依存するサービスを実装
- ビジネスロジック、検証、調整を処理
- ドメイン固有のエラータイプを返す

### ステート管理
- 操作のための `AppState` トレイトを定義
- サービスインスタンスを保持する `SharedAppState` 構造体を実装
- 依存性（データベースプール、リポジトリ、サービス）でサービスを初期化
- ステートコンストラクタで依存性注入

## エラー処理

### エラータイプ
- ドメイン固有のエラーのためのカスタムエラー列挙型を定義
- `From` トレイト実装で適切なエラー変換を使用
- クライアントエラー（4xx）とサーバーエラー（5xx）を区別

### エラー伝播
- エラー伝播には `?` 演算子を使用
- 下位レベルのエラーを適切な上位レベルのエラーに変換
- クライアントに機密情報を公開しないように適切にエラーをログ

## 非同期プログラミング

### 非同期関数
- I/Oバウンド操作には `async fn` を使用
- 非同期コンテキストでブロッキング操作を避ける
- 適切な非同期ランタイム機能を使用

### Futureと並行性
- Futureがいつ実行されるか、どのように適切に待機するかを理解
- CPU集約的なタスクには `tokio::spawn` を使用
- トレイト定義での非同期関数シグネチャに注意

## テスト

### テスト方針
- テストはコードと同じファイル内の `mod tests` にまとめる
- 実DBを使うテストは必ず `#[sqlx::test(migrations = "./migrations")]` を使う
- DB状態はテストごとにクリーン（新規DB生成 + 自動破棄）で共有しない
- API/ハンドラは `Router` を直接叩いて検証する

### DBテスト（モデル層）
目的はSQLやDB制約が正しく機能するかの検証に限定する。
```
#[sqlx::test(migrations = "./migrations")]
async fn create_and_find_user(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
  let created = User::create(&pool, "db-test@example.com", "DB Test", "password123").await?;
  let found = User::find_by_email(&pool, "db-test@example.com").await?;
  assert!(found.is_some());
  assert_eq!(created.id, found.unwrap().id);
  Ok(())
}
```

### API/ハンドラテスト
`src/test_support.rs` のユーティリティを使用し、`Router` に対してリクエストを送る。
DBの初期データが必要な場合はAPIを叩かず、モデル経由で事前投入する。
```
#[sqlx::test(migrations = "./migrations")]
async fn login_success(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
  let app = app_with_pool(pool.clone()).await;
  User::create(&pool, "api-login@example.com", "API Login", "password123").await?;

  let payload = LoginRequest {
    email: "api-login@example.com".to_string(),
    password: "password123".to_string(),
  };
  let (status, body) = post_json(app, "/api/v1/login", &payload).await;
  assert_eq!(status, StatusCode::OK);
  let _response: LoginResponse = serde_json::from_slice(&body).expect("deserialize response");
  Ok(())
}
```

### 実行方法
- Docker内で実行: `docker exec koko-pic-api-app-1 sh -c "cargo fmt && cargo clippy && cargo test"`
- `DATABASE_URL` はテストDB作成権限（`CREATE DATABASE`）を持つユーザーを使う

## セキュリティ

### 認証
- 認証にはJWTトークンを使用
- JWTシークレットを環境変数に格納
- 適切なトークン有効期限を実装

### 入力検証
- API境界ですべての入力を検証
- 処理前にユーザー入力をサニタイズ
- リクエストとレスポンスのための強力な型付きデータ構造を使用

### パスワード処理
- 保存前に常にパスワードをハッシュ化
- 安全なハッシュアルゴリズムを使用
- 平文パスワードを保存しない

## 依存関係

### Cargo.toml 管理
- 依存関係を最新に保つが、メジャーバージョンアップグレードには注意
- 明確でない依存関係の目的を文書化
- 再現可能なビルドのための特定バージョン範囲を使用

### 外部ライブラリ
- アクティブなコミュニティを持つ十分にメンテナンスされたライブラリを優先
- 依存関係のセキュリティ影響を評価
- 便利さと複雑さのトレードオフを考慮

## ドキュメント

### コードコメント
- パブリックAPIにはドキュメントコメント (`///`) を使用
- 自己説明的でない複雑なロジックにはインラインコメントを追加
- コード変更時にコメントを最新に保つ
- 「何をするか」ではなく「なぜそうするか」を説明することに焦点

### アーキテクチャドキュメント
- ドキュメントディレクトリにアーキテクチャ図を維持
- 主要な設計決定とその根拠を文書化
- APIドキュメントをコード変更と同期

## Gitワークフロー

### コミットメッセージ
- 従来のコミット形式に従う（例：`feat:`、`fix:`、`refactor:`）
- コミットメッセージは簡潔だが説明的
- 適用可能な場合は問題番号を参照

### ブランチ戦略
- 新機能には機能ブランチを使用
- メインブランチは常にデプロイ可能に保つ
- コードレビューにはプルリクエストを使用

## デプロイと運用

### 設定
- 設定には環境変数を使用
- ソースコードに値をハードコードしない
- 必要な環境変数の明確なドキュメントを提供

### ロギング
- 適切なログレベルで構造化ロギングを使用
- 機密情報をログに記録しない
- 関連するコンテキストをログメッセージに含める

## パフォーマンスに関する考慮事項

### データベースクエリ
- 接続プーリング（SQLx PgPool）を使用
- クエリを最適化し、適切なインデックスを使用
- 大きなデータセットにはページネーションを検討

### メモリ管理
- ホットパスでのメモリ割り当てに注意
- 使用ケースに適した適切なデータ構造を使用
- 潜在的なメモリリークを監視
